# АВС, задание 3

- **Автор**: Коннов Илья (@iliakonnov), БПИ201
- **Вариант**: 16

## Задание
Прочитать простые геометрические фигуры с цветом, отсортировать их по периметру при помощи straight sort и вывести.

# Запуск
```bash
./run.sh
```

# Использование
См. `./run.sh -h`

# Архитектура

Параметры компьютера:

- **Процессор:**  Intel(R) Core(TM) i5 CPU M 560 @ 2.67GHz
- **ОС:** Arch Linux
- **Kernel:** `Linux 5.14.14-arch1-1 x86_64`

см. файл `Архитектура.pdf`

# Модули
По одному модулю (`.py`) на каждый тип, получаем 7 модулей. Плюс драйвер `__main__.py`

# Производительность
```
> ./run.sh -f tests/in/1.txt -o tests/out/1.txt
Executed in    79.94 millis

> ./run.sh -f tests/in/1000.txt -o tests/out/1000.txt
Executed in    716.68 millis

> ./run.sh -f /tmp/tests/5000.in -o /tmp/tests/5000.out
Executed in    16.68 secs

> ./run.sh -f /tmp/tests/10000.in -o /tmp/tests/10000.out
Executed in    70.79 secs
```

В сравнении с [структурным](https://github.com/ik-hse-projects/avs-hw-1#%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C) и [объектно-ориентированным](https://github.com/ik-hse-projects/avs-hw-2#%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C) подходами, производительность значительно ниже. Объясняется это как низкой эффективностью реализации яызка Python, так и низкой производительностью динамически типизируемых языков в целом (накладные расходы гораздо выше). Я не хочу приводить прямое сравнение `CPython` с другими подходами, поскольку оно будет несколько некорректным, см. далее.

## Использование PyPy

Замена реализации языка с `CPython` на `PyPy` снижает время работы программы более чем в ≈10 раз, в зависимости от объёма данных.
```
> pypy3 -m AVS3 -f tests/in/1.txt -o tests/out/1.txt
Executed in  693.08 millis

> pypy3 -m AVS3 -f tests/in/1000.txt -o tests/out/1000.txt
Executed in  913.76 millis

> pypy3 -m AVS3 -f tests/in/5000.txt -o tests/out/5000.txt
Executed in    2.05 secs

> pypy3 -m AVS3 -f tests/in/10000.txt -o tests/out/10000.txt
Executed in    5.42 secs
```

Поскольку `PyPy` использует `JIT`-компиляцию, на маленьких тестах виртуальная машина не успевает прогреться и выполняется медленнее оригинального `CPython`. Видно, что практически 1.24 секунды уходят просто на запуск

Однако на достаточно больших тестах время работы примерно в два раза больше, чем у других двух реализаций (на `C` и на `C++`).

Интересно было бы добавить в сравнение LuaJIT, но, к сожалению, это выходит за рамки ТЗ и не влияет на оценку.
